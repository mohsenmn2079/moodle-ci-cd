{"version":3,"file":"dialoguedom.min.js","sources":["../../../src/local/activitychooser/dialoguedom.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {addIconToContainer} from 'core/loadingicon';\nimport Carousel from 'theme_boost/bootstrap/carousel';\nimport Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport selectors from 'core_course/local/activitychooser/selectors';\nimport Tab from 'theme_boost/bootstrap/tab';\nimport * as Templates from 'core/templates';\n\n\n/**\n * The activity changer dialogue DOM manipulation module.\n *\n * @module     core_course/local/activitychooser/dialoguedom\n * @copyright  2025 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class ChooserDialogueDOM {\n\n    constructor(dialogue, modalBody, exporter) {\n        this.modalBody = modalBody;\n        this.exporter = exporter;\n        // Temporal variable while migrating methods.\n        this.dialogue = dialogue;\n    }\n\n    /**\n     * Get the search input element.\n     *\n     * @return {HTMLElement} The search input element.\n     */\n    getSearchInputElement() {\n        return this.modalBody.querySelector(selectors.actions.search);\n    }\n\n    /**\n     * Get the closest chooser option element.\n     *\n     * @param {HTMLElement} element\n     * @return {HTMLElement|null} element\n     */\n    getClosestChooserOption(element) {\n        return element.closest(selectors.regions.chooserOption.container);\n    }\n\n    /**\n     * Check if the search tab is active.\n     *\n     * @return {Boolean} True if the search tab is active, false otherwise.\n     */\n    isFavoutiteTabActive() {\n        const favouriteTab = this.modalBody.querySelector(selectors.regions.favouriteTabNav);\n        return favouriteTab && favouriteTab.classList.contains('active');\n    }\n\n    /**\n     * Show the search results.\n     *\n     * @param {Object} searchResultsData Data containing the module items that satisfy the search criteria\n     */\n    async refreshSearchResults(searchResultsData) {\n        const searchResultsContainer = this.modalBody.querySelector(selectors.regions.searchResults);\n        const clearSearchButton = this.modalBody.querySelector(selectors.actions.clearSearch);\n\n        await this.renderSearchResults(searchResultsContainer, searchResultsData);\n        const chooserOptionsContainer = searchResultsContainer.querySelector(selectors.regions.chooserOptions);\n        const firstSearchResultItem = chooserOptionsContainer.querySelector(selectors.regions.chooserOption.container);\n        if (firstSearchResultItem) {\n            // Set the first result item to be focusable.\n            this.toggleFocusableChooserOption(firstSearchResultItem, true);\n            // Register keyboard events on the created search result items.\n        }\n        clearSearchButton.classList.remove('d-none');\n\n        // Results are rendered in the all activities tab, so we need to hide the category content.\n        const tabContent = searchResultsContainer.closest(selectors.regions.tabContent);\n        const categoryContent = tabContent.querySelector(selectors.regions.categoryContent);\n        categoryContent.classList.add('d-none');\n    }\n\n    /**\n     * Clear the search results.\n     */\n    cleanSearchResults() {\n        const searchResultsContainer = this.modalBody.querySelector(selectors.regions.searchResults);\n        const clearSearchButton = this.modalBody.querySelector(selectors.actions.clearSearch);\n        searchResultsContainer.innerHTML = '';\n        clearSearchButton.classList.add('d-none');\n\n        // Results are rendered in the all activities tab, so we need to show the category content again.\n        const tabContent = searchResultsContainer.closest(selectors.regions.tabContent);\n        const categoryContent = tabContent.querySelector(selectors.regions.categoryContent);\n        categoryContent.classList.remove('d-none');\n    }\n\n    /**\n     * Render the search results in a defined container\n     *\n     * @private\n     * @method renderSearchResults\n     * @param {HTMLElement} searchResultsContainer The container where the data should be rendered\n     * @param {Object} searchResultsData Data containing the module items that satisfy the search criteria\n     */\n    async renderSearchResults(searchResultsContainer, searchResultsData) {\n        const templateData = this.exporter.getSearchResultData(searchResultsData);\n        // Build up the html & js ready to place into the help section.\n        const {html, js} = await Templates.renderForPromise(\n            'core_course/local/activitychooser/search_results',\n            templateData\n        );\n        await Templates.replaceNodeContents(searchResultsContainer, html, js);\n    }\n\n    /**\n     * Show the \"All activities\" tab.\n     *\n     * @method showAllActivitiesTab\n     * @return {HTMLElement} The \"All activities\" tab element.\n     */\n    showAllActivitiesTab() {\n        const navTab = this.modalBody.querySelector(selectors.regions.allTabNav);\n\n        if (navTab.classList.contains('active')) {\n            return navTab;\n        }\n\n        const pendingPromise = new Pending('core_course/activitychooser:alltab');\n        navTab.addEventListener('shown.bs.tab', pendingPromise.resolve, {once: true});\n\n        Tab.getOrCreateInstance(navTab).show();\n        return navTab;\n    }\n\n    /**\n     * Update the starred icons in the chooser modal.\n     *\n     * @method updateItemStarredIcons\n     * @param {String} internal The internal name of the module.\n     * @param {Boolean} favourite Whether the module is a favourite or not.\n     */\n    updateItemStarredIcons(internal, favourite) {\n        const favouriteButtons = this.modalBody.querySelectorAll(\n            `${selectors.elements.moduleItem(internal)} ${selectors.actions.optionActions.manageFavourite}`\n        );\n        Array.from(favouriteButtons).forEach((element) => {\n            element.classList.toggle('text-muted', !favourite);\n            element.classList.toggle('text-primary', favourite);\n            element.dataset.favourited = favourite;\n            element.setAttribute('aria-pressed', favourite);\n            element.querySelector(selectors.elements.favouriteIconActive)?.classList.toggle('d-none', !favourite);\n            element.querySelector(selectors.elements.favouriteIconInactive)?.classList.toggle('d-none', favourite);\n\n            const iconSelectsor = favourite ? selectors.elements.favouriteIconActive : selectors.elements.favouriteIconInactive;\n            const favouriteIcon = element.querySelector(iconSelectsor);\n            element.setAttribute('aria-label', favouriteIcon?.getAttribute('data-action-label') || '');\n        });\n    }\n\n    /**\n     * Refresh the favourite content.\n     *\n     * @param {Array} mappedModules The modules to be displayed in the favourite tab.\n     */\n    async refreshFavouritesTabContent(mappedModules) {\n        const templateData = await this.exporter.getFavouriteTabData(mappedModules);\n        const favouriteArea = this.modalBody.querySelector(selectors.regions.favouriteTab);\n        const {html, js} = await Templates.renderForPromise(\n            'core_course/local/activitychooser/tabcontent',\n            templateData,\n        );\n        await Templates.replaceNodeContents(favouriteArea, html, js);\n    }\n\n    /**\n     * Toggle the display of the favourite tab.\n     *\n     * The favourite tab is only displayed when there are favourite modules\n     * or when it is the active tab.\n     *\n     * @param {Boolean} displayed Whether we want to show or hide the favourite tab\n     */\n    toggleFavouriteTabDisplay(displayed) {\n        const favouriteTabNav = this.modalBody.querySelector(selectors.regions.favouriteTabNav);\n\n        let moveFocusTo;\n        if (!displayed && favouriteTabNav.classList.contains('active')) {\n            moveFocusTo = this.showAllActivitiesTab();\n        }\n\n        favouriteTabNav?.classList.toggle('d-none', !displayed);\n        favouriteTabNav.tabIndex = displayed ? 0 : -1;\n        // The disabled class is used by Boostrap Tab for keyboard navigation.\n        if (displayed) {\n            favouriteTabNav.classList.remove('disabled');\n        } else {\n            favouriteTabNav.classList.add('disabled');\n        }\n\n        if (moveFocusTo) {\n            moveFocusTo.focus();\n        }\n        this.initActiveTabNavigation();\n    }\n\n    /**\n     * Given an event from the main module 'page' navigate to it's help section via a carousel.\n     *\n     * @method showModuleHelp\n     * @param {Object} moduleData Data of the module to carousel to\n     * @param {Modal} modal The modal object\n     */\n    showModuleHelp(moduleData, modal) {\n        const carousel = this.modalBody.querySelector(selectors.regions.carousel);\n        // If we have a real footer then we need to change temporarily.\n        if (moduleData.showFooter === true) {\n            modal.setFooter(Templates.render(\n                'core_course/local/activitychooser/footer_partial',\n                moduleData\n            ));\n        }\n        const help = carousel.querySelector(selectors.regions.help);\n        help.innerHTML = '';\n        help.classList.add('m-auto');\n\n        // Add a spinner.\n        const spinnerPromise = addIconToContainer(help);\n\n        // Used later...\n        let transitionPromiseResolver = null;\n        const transitionPromise = new Promise(resolve => {\n            transitionPromiseResolver = resolve;\n        });\n\n        // Build up the html & js ready to place into the help section.\n        const contentPromise = Templates.renderForPromise(\n            'core_course/local/activitychooser/help',\n            moduleData\n        );\n\n        // Wait for the content to be ready, and for the transition to be complet.\n        Promise.all([contentPromise, spinnerPromise, transitionPromise])\n            .then(([{html, js}]) => Templates.replaceNodeContents(help, html, js))\n            .then(() => {\n                help.querySelector(selectors.regions.chooserSummary.header).focus();\n                return help;\n            })\n            .catch(Notification.exception);\n\n        // Move to the next slide, and resolve the transition promise when it's done.\n        carousel.addEventListener(\n            'slid.bs.carousel',\n            () => {\n                transitionPromiseResolver();\n            },\n            {once: true}\n        );\n        // Trigger the transition between 'pages'.\n        Carousel.getInstance(carousel).next();\n    }\n\n    /**\n     * Hide the help section of the chooser.\n     *\n     * @param {String|null} internal The internal name of the module to return to, if any.\n     */\n    hideModuleHelp(internal = null) {\n        const carousel = this.modalBody.querySelector(selectors.regions.carousel);\n        // Trigger the transition between 'pages'.\n        Carousel.getInstance(carousel).prev();\n        if (internal === null) {\n            return;\n        }\n        carousel.addEventListener(\n            'slid.bs.carousel',\n            () => {\n                this.focusChooserOption(internal);\n            },\n            {once: true}\n        );\n    }\n\n    /**\n     * Focus on a specific activity inside the active tab (if present).\n     *\n     * @private\n     * @method focusChooserOption\n     * @param {String} internal The internal name of the module.\n     */\n    focusChooserOption(internal) {\n        const currentTabNav = this.modalBody.querySelector(selectors.elements.activetab);\n        const activeSectionId = currentTabNav.getAttribute(\"href\");\n        const sectionChooserOptions = this.modalBody.querySelector(selectors.regions.getSectionChooserOptions(activeSectionId));\n        const newCurrent = sectionChooserOptions.querySelector(selectors.regions.getModuleSelector(internal));\n\n        if (!newCurrent) {\n            throw new Error(`Invalid chooser option to focus on: ${internal}`);\n        }\n\n        // Chooser can only have one element focusable at a time, so we disable them all first.\n        this.disableFocusAllChooserOptions(currentTabNav);\n        this.toggleFocusableChooserOption(newCurrent, true);\n\n        // Little hack: we want the element considered a focus-visible element.\n        // But the focus method does not trigger the focus-visible class. There's an\n        // experimental \"{focusVisible: true}\" option in the focus method, but it's not\n        // supported in all browsers yet so we need to fake an editable element.\n        newCurrent.contentEditable = true;\n        newCurrent.focus();\n        newCurrent.contentEditable = false;\n    }\n\n    /**\n     * Initialise the active tab navigation.\n     */\n    initActiveTabNavigation() {\n        const activeSectionId = this.modalBody.querySelector(selectors.elements.activetab).getAttribute(\"href\");\n        const sectionChooserOptions = this.modalBody.querySelector(selectors.regions.getSectionChooserOptions(activeSectionId));\n        const firstChooserOption = sectionChooserOptions?.querySelector(selectors.regions.chooserOption.container);\n        if (!firstChooserOption) {\n            return;\n        }\n        this.toggleFocusableChooserOption(firstChooserOption, true);\n    }\n\n    /**\n     * Initialise all Boostrap components.\n     */\n    initBootstrapComponents() {\n        this.modalBody.querySelectorAll(selectors.elements.tab).forEach((navTab) => {\n            // Init the Bootstrap Tab navigation.\n            Tab.getOrCreateInstance(navTab);\n        });\n\n        // Set up the carousel.\n        const carousel = this.modalBody.querySelector(selectors.regions.carousel);\n        new Carousel(carousel, {\n            interval: false,\n            pause: true,\n            keyboard: false\n        });\n    }\n\n    /**\n     * Disable the focus of all chooser options in a specific container (section).\n     *\n     * @method disableFocusAllChooserOptions\n     * @param {HTMLElement} tabNav The tab navigation element (from the shown.bs.ta event).\n     */\n    disableFocusAllChooserOptions(tabNav) {\n        const tabId = tabNav.getAttribute(\"href\");\n        const chooserOptions = this.modalBody.querySelector(\n            selectors.regions.getSectionChooserOptions(tabId)\n        );\n\n        if (chooserOptions === null) {\n            return;\n        }\n\n        const allChooserOptions = chooserOptions.querySelectorAll(selectors.regions.chooserOption.container);\n        allChooserOptions.forEach((chooserOption) => {\n            this.toggleFocusableChooserOption(chooserOption, false);\n        });\n    }\n\n    /**\n     * Add or remove a chooser option from the focus order.\n     *\n     * @private\n     * @method toggleFocusableChooserOption\n     * @param {HTMLElement} chooserOption The chooser option element which should be added or removed from the focus order\n     * @param {Boolean} isFocusable Whether the chooser element is focusable or not\n     */\n    toggleFocusableChooserOption(chooserOption, isFocusable) {\n        const chooserOptionLink = chooserOption.querySelector(selectors.actions.addChooser);\n        const chooserOptionHelp = chooserOption.querySelector(selectors.actions.optionActions.showSummary);\n        const chooserOptionFavourite = chooserOption.querySelector(selectors.actions.optionActions.manageFavourite);\n\n        if (isFocusable) {\n            // Set tabindex to 0 to add current chooser option element to the focus order.\n            chooserOption.tabIndex = 0;\n            chooserOptionLink.tabIndex = 0;\n            chooserOptionHelp.tabIndex = 0;\n            chooserOptionFavourite.tabIndex = 0;\n        } else {\n            // Set tabindex to -1 to remove the previous chooser option element from the focus order.\n            chooserOption.tabIndex = -1;\n            chooserOptionLink.tabIndex = -1;\n            chooserOptionHelp.tabIndex = -1;\n            chooserOptionFavourite.tabIndex = -1;\n        }\n    }\n\n    /**\n     * Move the focus to the previous chooser option element.\n     *\n     * @param {HTMLElement} current The current chooser option element\n     */\n    focusNextChooserOption(current) {\n        this.moveChooserOptionFocus(\n            current,\n            (currentOption) => currentOption.nextElementSibling ?? currentOption,\n        );\n    }\n\n    /**\n     * Move the focus to the previous chooser option element.\n     *\n     * @param {HTMLElement} current The current chooser option element\n     */\n    focusPreviousChooserOption(current) {\n        this.moveChooserOptionFocus(\n            current,\n            (currentOption) => currentOption.previousElementSibling ?? currentOption,\n        );\n    }\n\n    /**\n     * Move the focus to the first chooser option element.\n     *\n     * @param {HTMLElement} current The current chooser option element\n     */\n    focusFirstChooserOption(current) {\n        this.moveChooserOptionFocus(\n            current,\n            (currentOption, container) => container.firstElementChild ?? currentOption,\n        );\n    }\n\n    /**\n     * Move the focus to the last chooser option element.\n     *\n     * @param {HTMLElement} current The current chooser option element\n     */\n    focusLastChooserOption(current) {\n        this.moveChooserOptionFocus(\n            current,\n            (currentOption, container) => container.lastElementChild ?? currentOption,\n        );\n    }\n\n    /**\n     * Move the focus to the next chooser option element.\n     *\n     * @private\n     * @param {HTMLElement} current The current chooser option element\n     * @param {Function} getNextFocus Function to get the next focusable element\n     */\n    moveChooserOptionFocus(current, getNextFocus) {\n        const currentOption = this.getClosestChooserOption(current);\n        const container = current.closest(selectors.regions.chooserOptions);\n\n        if (!container || !currentOption) {\n            throw new Error('Invalid chooser options container or current option');\n        }\n\n        const newFocusOption = getNextFocus(currentOption, container);\n        if (!newFocusOption) {\n            return;\n        }\n\n        this.toggleFocusableChooserOption(currentOption, false);\n        this.toggleFocusableChooserOption(newFocusOption, true);\n        newFocusOption.focus();\n    }\n}\n"],"names":["constructor","dialogue","modalBody","exporter","getSearchInputElement","this","querySelector","selectors","actions","search","getClosestChooserOption","element","closest","regions","chooserOption","container","isFavoutiteTabActive","favouriteTab","favouriteTabNav","classList","contains","searchResultsData","searchResultsContainer","searchResults","clearSearchButton","clearSearch","renderSearchResults","firstSearchResultItem","chooserOptions","toggleFocusableChooserOption","remove","tabContent","categoryContent","add","cleanSearchResults","innerHTML","templateData","getSearchResultData","html","js","Templates","renderForPromise","replaceNodeContents","showAllActivitiesTab","navTab","allTabNav","pendingPromise","Pending","addEventListener","resolve","once","getOrCreateInstance","show","updateItemStarredIcons","internal","favourite","favouriteButtons","querySelectorAll","elements","moduleItem","optionActions","manageFavourite","Array","from","forEach","toggle","dataset","favourited","setAttribute","favouriteIconActive","favouriteIconInactive","iconSelectsor","favouriteIcon","getAttribute","mappedModules","getFavouriteTabData","favouriteArea","toggleFavouriteTabDisplay","displayed","moveFocusTo","tabIndex","focus","initActiveTabNavigation","showModuleHelp","moduleData","modal","carousel","showFooter","setFooter","render","help","spinnerPromise","transitionPromiseResolver","transitionPromise","Promise","contentPromise","all","then","_ref","chooserSummary","header","catch","Notification","exception","getInstance","next","hideModuleHelp","prev","focusChooserOption","currentTabNav","activetab","activeSectionId","newCurrent","getSectionChooserOptions","getModuleSelector","Error","disableFocusAllChooserOptions","contentEditable","sectionChooserOptions","firstChooserOption","initBootstrapComponents","tab","Carousel","interval","pause","keyboard","tabNav","tabId","isFocusable","chooserOptionLink","addChooser","chooserOptionHelp","showSummary","chooserOptionFavourite","focusNextChooserOption","current","moveChooserOptionFocus","currentOption","nextElementSibling","focusPreviousChooserOption","previousElementSibling","focusFirstChooserOption","firstElementChild","focusLastChooserOption","lastElementChild","getNextFocus","newFocusOption"],"mappings":"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"}